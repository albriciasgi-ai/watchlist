<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Resumen Desarrollo Range Detector</title>
  <style>
    @page {
      margin: 2cm;
      size: A4;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      line-height: 1.6;
      color: #333;
      max-width: 210mm;
      margin: 0 auto;
      padding: 20px;
      background: white;
    }

    h1 {
      color: #2196F3;
      border-bottom: 3px solid #2196F3;
      padding-bottom: 10px;
      margin-top: 30px;
      page-break-after: avoid;
    }

    h2 {
      color: #1976D2;
      border-bottom: 2px solid #E3F2FD;
      padding-bottom: 8px;
      margin-top: 25px;
      page-break-after: avoid;
    }

    h3 {
      color: #0D47A1;
      margin-top: 20px;
      page-break-after: avoid;
    }

    code {
      background: #f5f5f5;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'Consolas', 'Monaco', monospace;
      font-size: 0.9em;
      color: #d32f2f;
    }

    pre {
      background: #263238;
      color: #ECEFF1;
      padding: 15px;
      border-radius: 5px;
      overflow-x: auto;
      page-break-inside: avoid;
    }

    pre code {
      background: none;
      color: #ECEFF1;
      padding: 0;
    }

    table {
      border-collapse: collapse;
      width: 100%;
      margin: 20px 0;
      page-break-inside: avoid;
    }

    th, td {
      border: 1px solid #ddd;
      padding: 12px;
      text-align: left;
    }

    th {
      background: #2196F3;
      color: white;
      font-weight: bold;
    }

    tr:nth-child(even) {
      background: #f5f5f5;
    }

    ul, ol {
      margin: 15px 0;
      padding-left: 30px;
    }

    li {
      margin: 8px 0;
    }

    hr {
      border: none;
      border-top: 2px solid #E0E0E0;
      margin: 30px 0;
    }

    .checkmark {
      color: #4CAF50;
      font-weight: bold;
    }

    a {
      color: #2196F3;
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }

    blockquote {
      border-left: 4px solid #2196F3;
      padding-left: 20px;
      margin: 20px 0;
      color: #666;
      font-style: italic;
    }

    .page-break {
      page-break-after: always;
    }

    @media print {
      body {
        padding: 0;
      }

      h1, h2, h3 {
        page-break-after: avoid;
      }

      pre, table {
        page-break-inside: avoid;
      }
    }
  </style>
</head>
<body>
<h1>Resumen Completo: Desarrollo del Range Detector</h1>
<h2>Plataforma de Trading - Volume Profile & Range Detection</h2>
<hr>
<h2>Tabla de Contenidos</h2>
<ul><li><a href="#descripci√≥n-general-del-sistema">Descripci√≥n General del Sistema</a></li>
<li><a href="#arquitectura-del-range-detector">Arquitectura del Range Detector</a></li>
<li><a href="#algoritmo-atr-based-range-detection">Algoritmo ATR-Based Range Detection</a></li>
<li><a href="#funcionalidades-implementadas">Funcionalidades Implementadas</a></li>
<li><a href="#integraciones-con-volume-profile">Integraciones con Volume Profile</a></li>
<li><a href="#mejoras-de-uiux">Mejoras de UI/UX</a></li>
<li><a href="#configuraci√≥n-y-personalizaci√≥n">Configuraci√≥n y Personalizaci√≥n</a></li>
<li><a href="#archivos-del-sistema">Archivos del Sistema</a></li>
<li><a href="#flujo-de-datos">Flujo de Datos</a></li>
<li><a href="#casos-de-uso">Casos de Uso</a></li>
</ul>
<hr>
<h2>Descripci√≥n General del Sistema</h2>
<p>El <strong>Range Detector</strong> es un sistema avanzado de an√°lisis t√©cnico que identifica autom√°ticamente zonas de consolidaci√≥n (rangos) en el mercado de criptomonedas, utilizando el indicador ATR (Average True Range) como base matem√°tica.</p>
<h3>Objetivo Principal</h3>
Detectar per√≠odos donde el precio se mueve lateralmente dentro de l√≠mites definidos, diferenci√°ndolos de per√≠odos de tendencia (breakouts).
<h3>Caracter√≠sticas Clave</h3>
<ul><li><span class="checkmark">‚úÖ</span> Detecci√≥n autom√°tica de rangos usando ATR</li>
<li><span class="checkmark">‚úÖ</span> Creaci√≥n autom√°tica de Volume Profiles en rangos detectados</li>
<li><span class="checkmark">‚úÖ</span> Volume Profiles de tendencia entre rangos</li>
<li><span class="checkmark">‚úÖ</span> Detecci√≥n de clusters de alto volumen (zonas de soporte/resistencia)</li>
<li><span class="checkmark">‚úÖ</span> Sistema de etiquetado alfab√©tico (A, B, C...)</li>
<li><span class="checkmark">‚úÖ</span> Persistencia en localStorage por s√≠mbolo y timeframe</li>
<li><span class="checkmark">‚úÖ</span> Configuraci√≥n granular por timeframe</li>
<li><span class="checkmark">‚úÖ</span> Control individual de visibilidad de rangos</li>
</ul>
<hr>
<h2>Arquitectura del Range Detector</h2>
<h3>Componentes Principales</h3>
<p>#### 1. ATRBasedRangeDetector.js
<strong>Ubicaci√≥n</strong>: <code>frontend/src/components/indicators/ATRBasedRangeDetector.js</code></p>
<p><strong>Responsabilidades</strong>:
<ul><li>C√°lculo del ATR (Average True Range)</li>
<li>L√≥gica de detecci√≥n de rangos</li>
<li>Gesti√≥n del estado de rangos activos</li>
<li>Detecci√≥n de breakouts</li>
<li>Etiquetado autom√°tico</li>
</ul>
<strong>Configuraci√≥n</strong>:
<pre><code class="language-javascript">{
  minRangeLength: 20,        // M√≠nimo de velas para considerar un rango
  atrMultiplier: 1.0,        // Multiplicador del ATR para l√≠mites
  atrLength: 200,            // Per√≠odo del ATR
  maxActiveRanges: 10,       // M√°ximo de rangos simult√°neos
  autoCreateFixedRange: true, // Crear VP autom√°ticamente
  maxBreakoutCandles: 5,     // Velas consecutivas para confirmar breakout
  createTrendProfiles: false, // Crear VP entre rangos
  showOtherTimeframes: false  // Mostrar rangos de otros TF
}
</code></pre></p>
<p>#### 2. IndicatorManager.js
<strong>Ubicaci√≥n</strong>: <code>frontend/src/components/indicators/IndicatorManager.js</code></p>
<p><strong>Responsabilidades</strong>:
<ul><li>Coordinar todos los indicadores del s√≠mbolo</li>
<li>Gestionar Volume Profiles fijos y din√°micos</li>
<li>Sincronizar rangos detectados con localStorage</li>
<li>Filtrar rangos por timeframe</li>
<li>Renderizar indicadores en el canvas</li>
</ul>
<strong>M√©todos Clave</strong>:
<pre><code class="language-javascript">enableRangeDetection(config)           // Activar detecci√≥n
disableRangeDetection()                // Desactivar detecci√≥n
syncFixedRangeIndicators()             // Sincronizar desde localStorage
createTrendProfilesBetweenRanges()    // Crear VP de tendencias
renderFixedRangeProfiles()             // Renderizar con filtros
saveRangeDetectionConfig()             // Guardar config por TF
loadRangeDetectionConfig()             // Cargar config por TF
</code></pre></p>
<p>#### 3. RangeDetectionSettings.jsx
<strong>Ubicaci√≥n</strong>: <code>frontend/src/components/RangeDetectionSettings.jsx</code></p>
<p><strong>Responsabilidades</strong>:
<ul><li>UI de configuraci√≥n del Range Detector</li>
<li>Gesti√≥n de par√°metros ATR</li>
<li>Lista de rangos detectados con checkboxes</li>
<li>Toggles de funcionalidades</li>
<li>Activaci√≥n/desactivaci√≥n por s√≠mbolo</li>
</ul>
<hr></p>
<h2>Algoritmo ATR-Based Range Detection</h2>
<h3>Paso 1: C√°lculo del ATR</h3>
<pre><code class="language-javascript">calculateATR(candles, period = 200) {
  const trueRanges = [];
<p>  for (let i = 1; i < candles.length; i++) {
    const high = candles[i].high;
    const low = candles[i].low;
    const prevClose = candles[i - 1].close;</p>
<p>    const tr = Math.max(
      high - low,
      Math.abs(high - prevClose),
      Math.abs(low - prevClose)
    );</p>
<p>    trueRanges.push(tr);
  }</p>
<p>  // Media m√≥vil simple de los True Ranges
  const sum = trueRanges.slice(-period).reduce((a, b) => a + b, 0);
  return sum / Math.min(period, trueRanges.length);
}
</code></pre></p>
<h3>Paso 2: Detecci√≥n de Rangos</h3>
<p>Un rango se detecta cuando:</p>
<ul><li><strong>Inicio del Rango</strong>:</li>
</ul>   - Precio est√° contenido dentro de bandas ATR
   - <code>high <= initialHigh + (atr * atrMultiplier)</code>
   - <code>low >= initialLow - (atr * atrMultiplier)</code>
<ul><li><strong>Mantenimiento del Rango</strong>:</li>
</ul>   - Cada vela nueva respeta los l√≠mites
   - Se actualiza el rango detectado
   - Longitud del rango incrementa
<ul><li><strong>Validaci√≥n del Rango</strong>:</li>
</ul>   - Longitud >= <code>minRangeLength</code> velas
   - No hay breakout confirmado
<h3>Paso 3: Detecci√≥n de Breakout</h3>
<p>Un breakout se confirma cuando:</p>
<pre><code class="language-javascript">if (breakoutCandleCount >= maxBreakoutCandles) {
  // Breakout confirmado
  if (rangeLength >= minRangeLength) {
    // Guardar rango como v√°lido
    validatedRanges.push(currentRange);
  }
  // Reiniciar detecci√≥n
  currentRange = null;
}
</code></pre>
<h3>Paso 4: Creaci√≥n de Volume Profile</h3>
<p>Cuando un rango es validado:</p>
<pre><code class="language-javascript">const rangeProfile = {
  rangeId: <code>range_${range.id}</code>,
  symbol: this.symbol,
  interval: this.interval,
  startTimestamp: range.startTimestamp,
  endTimestamp: range.endTimestamp,
  enabled: true,
  isAutoDetected: true,
  rangeLabel: range.label,  // "A", "B", "C"...
  detectionScore: range.score,
  rows: 100,
  valueAreaPercent: 70,
  enableClusterDetection: true,
  clusterColor: "#E65100",  // Naranja oscuro
  baseColor: "#9C27B0"      // P√∫rpura
};
</code></pre>
<hr>
<h2>Funcionalidades Implementadas</h2>
<h3>1. Sistema de Etiquetado Alfab√©tico</h3>
<p><strong>Implementaci√≥n</strong>: <code>ATRBasedRangeDetector.js:124-132</code></p>
<pre><code class="language-javascript">assignRangeLabels() {
  const labels = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  this.detectedRanges.forEach((range, index) => {
    if (index < labels.length) {
      range.label = labels[index];
    } else {
      const quotient = Math.floor(index / labels.length) - 1;
      const remainder = index % labels.length;
      range.label = labels[quotient] + labels[remainder];
    }
  });
}
</code></pre>
<p><strong>Resultado</strong>: Rangos etiquetados como A, B, C... AA, AB, AC...</p>
<h3>2. Separaci√≥n por Timeframe</h3>
<p><strong>Problema Resuelto</strong>: Rangos de diferentes timeframes se traslapaban</p>
<p><strong>Soluci√≥n</strong>: <code>IndicatorManager.js:175-213</code></p>
<pre><code class="language-javascript">renderFixedRangeProfiles(ctx, bounds, visibleCandles, allCandles, priceContext) {
  const showOtherTimeframes = this.rangeDetector?.config.showOtherTimeframes || false;
<p>  const activeIndicators = this.fixedRangeIndicators.filter(indicator => {
    const profile = this.fixedRangeProfiles.find(p => p.rangeId === indicator.rangeId);</p>
<p>    // Rangos manuales siempre visibles
    if (!profile || !profile.isAutoDetected) {
      return true;
    }</p>
<p>    // Rangos auto-detectados filtrados por timeframe
    if (showOtherTimeframes) {
      return true;
    } else {
      return profile.interval === this.interval;
    }
  });</p>
<p>  // Renderizar
  activeIndicators.forEach(indicator => {
    indicator.renderOverlay(ctx, bounds, visibleCandles, allCandles, priceContext);
  });
}
</code></pre></p>
<p><strong>Features</strong>:
<ul><li>Por defecto: solo rangos del timeframe actual</li>
<li>Opci√≥n: mostrar rangos de todos los timeframes</li>
<li>Rangos manuales siempre visibles</li>
</ul>
<h3>3. Volume Profiles de Tendencia</h3></p>
<p><strong>Concepto</strong>: Crear VP en los gaps entre rangos detectados (zonas de tendencia)</p>
<p><strong>Implementaci√≥n</strong>: <code>IndicatorManager.js:539-624</code></p>
<pre><code class="language-javascript">createTrendProfilesBetweenRanges() {
  // Obtener rangos auto-detectados ordenados
  const autoRanges = this.getAutoDetectedRanges()
    .filter(p => !p.isTrendProfile)
    .sort((a, b) => a.startTimestamp - b.startTimestamp);
<p>  // Detectar gaps entre rangos consecutivos
  for (let i = 0; i < autoRanges.length - 1; i++) {
    const currentRange = autoRanges[i];
    const nextRange = autoRanges[i + 1];
    const gapStart = currentRange.endTimestamp;
    const gapEnd = nextRange.startTimestamp;</p>
<p>    // Verificar si ya existe
    const gapExists = this.fixedRangeProfiles.some(p =>
      p.isTrendProfile &&
      p.startTimestamp === gapStart &&
      p.endTimestamp === gapEnd
    );</p>
<p>    if (!gapExists && (gapEnd - gapStart > 60000)) {
      // Crear VP de tendencia
      const trendProfile = {
        rangeId: <code>trend_${gapStart}_${gapEnd}</code>,
        isTrendProfile: true,
        baseColor: "#2196F3",  // Azul para tendencias
        clusterColor: "#FF6F00", // Naranja para clusters
        // ... resto de config
      };</p>
<p>      this.fixedRangeProfiles.push(trendProfile);
    }
  }
}
</code></pre></p>
<p><strong>Caracter√≠sticas</strong>:
<ul><li>Color azul distintivo (#2196F3)</li>
<li>Toggle ON/OFF en settings</li>
<li>Default: desactivado</li>
<li>Se actualiza autom√°ticamente al detectar nuevos rangos</li>
</ul>
<h3>4. Detecci√≥n de Clusters</h3></p>
<p><strong>Configuraci√≥n</strong>: Activada por defecto en rangos auto-detectados</p>
<pre><code class="language-javascript">enableClusterDetection: true,
clusterThreshold: 1.5,
clusterColor: "#E65100"  // Naranja oscuro
</code></pre>
<p><strong>Algoritmo</strong>: Detecta zonas de alto volumen (>1.5x promedio) y las marca visualmente</p>
<h3>5. Control Individual de Visibilidad</h3>
<p><strong>UI</strong>: Checkboxes en lista de rangos</p>
<p><strong>Handler</strong>: <code>RangeDetectionSettings.jsx:118-136</code></p>
<pre><code class="language-javascript">const handleToggleRange = (rangeId, currentlyEnabled) => {
  const indicator = indicatorManager.fixedRangeIndicators.find(
    ind => ind.rangeId === rangeId
  );
  const profile = indicatorManager.fixedRangeProfiles.find(
    p => p.rangeId === rangeId
  );
<p>  if (indicator && profile) {
    indicator.enabled = !currentlyEnabled;
    profile.enabled = !currentlyEnabled;
    indicatorManager.saveFixedRangeProfilesToStorage();
    setConfig({ ...config }); // Force re-render
  }
};
</code></pre></p>
<p><strong>Persistencia</strong>: Estado guardado en localStorage</p>
<h3>6. Configuraci√≥n por Timeframe</h3>
<p><strong>Problema</strong>: Diferentes timeframes requieren diferentes par√°metros ATR</p>
<p><strong>Soluci√≥n</strong>: localStorage keys incluyen s√≠mbolo + interval</p>
<pre><code class="language-javascript">// Guardar
saveRangeDetectionConfig() {
  const configKey = <code>range_detection_config_${this.symbol}_${this.interval}</code>;
  localStorage.setItem(configKey, JSON.stringify({
    enabled: true,
    config: this.rangeDetector.config,
    lastUpdate: Date.now()
  }));
}
<p>// Cargar
loadRangeDetectionConfig() {
  const configKey = <code>range_detection_config_${this.symbol}_${this.interval}</code>;
  const stored = localStorage.getItem(configKey);
  if (stored) {
    const { config } = JSON.parse(stored);
    this.enableRangeDetection(config);
  }
}
</code></pre></p>
<p><strong>Resultado</strong>: Cada s√≠mbolo puede tener diferentes configs para 15m, 1h, 4h, etc.</p>
<hr>
<h2>Integraciones con Volume Profile</h2>
<h3>VolumeProfileFixedRangeIndicator.js</h3>
<p>El Range Detector crea autom√°ticamente instancias de Volume Profile fijo para cada rango detectado.</p>
<p><strong>Configuraci√≥n t√≠pica</strong>:
<pre><code class="language-javascript">{
  rows: 100,                    // Bins de precio
  valueAreaPercent: 70,         // √Årea de valor (70% del volumen)
  histogramMaxWidth: 25,        // Ancho m√°ximo del histograma
  useGradient: true,            // Gradiente de color
  baseColor: "#9C27B0",         // P√∫rpura para rangos
  valueAreaColor: "#BA68C8",    // P√∫rpura claro para VA
  pocColor: "#7B1FA2",          // P√∫rpura oscuro para POC
  vahValColor: "#AB47BC",       // L√≠neas VAH/VAL
  rangeShadeColor: "#E1BEE7",   // Sombreado del rango
  enableClusterDetection: true, // Detectar clusters
  clusterThreshold: 1.5,        // 150% del promedio
  clusterColor: "#E65100"       // Naranja oscuro
}
</code></pre></p>
<h3>Diferencias Visuales</h3>
<table><thead><tr><th>Elemento</th><th>Rangos Laterales</th><th>Tendencias</th></tr></thead><tbody><tr><td>Color base</td><td>P√∫rpura (#9C27B0)</td><td>Azul (#2196F3)</td></tr><tr><td>Etiqueta</td><td>A, B, C...</td><td>Sin etiqueta</td></tr><tr><td>Clusters</td><td>Naranja oscuro</td><td>Naranja brillante</td></tr><tr><td>Sombreado</td><td>P√∫rpura claro</td><td>Azul claro</td></tr></tbody></table>
<hr>
<h2>Mejoras de UI/UX</h2>
<h3>1. Crosshair Estilo TradingView</h3>
<p><strong>Implementaci√≥n</strong>: <code>MiniChart.jsx:373-447</code></p>
<p><strong>Caracter√≠sticas</strong>:
<ul><li>L√≠neas gruesas (2px) para mejor visibilidad</li>
<li>Fecha/hora en eje X sin a√±o (formato: "DD MMM HH:mm")</li>
<li>Precio en eje Y</li>
<li>Interpolaci√≥n entre velas para posici√≥n exacta del mouse</li>
<li>Tooltip flotante eliminado</li>
</ul>
<strong>Interpolaci√≥n de Timestamp</strong>:
<pre><code class="language-javascript">const candle1 = visibleCandles[candleIdx];
const candle2 = visibleCandles[candleIdx + 1];
const fraction = mousePositionInChart - candleIdx;
const interpolatedTimestamp = candle1.timestamp +
  (candle2.timestamp - candle1.timestamp) * fraction;
</code></pre></p>
<h3>2. Zoom Vertical con Anclaje en Mouse</h3>
<p><strong>Fix Cr√≠tico</strong>: <code>MiniChart.jsx:694-755</code></p>
<p><strong>Problema Original</strong>:
<ul><li><code>handleWheel</code> usaba c√°lculos simplificados de <code>priceChartHeight</code></li>
<li>No inclu√≠a <code>inProgressCandle</code> en displayCandles</li>
<li><code>marginTop</code> incorrecto (30 vs 25)</li>
</ul>
<strong>Soluci√≥n</strong>:
<pre><code class="language-javascript">// Calcular altura exacta como en drawChart
const availableHeight = height - marginTop - timeAxisHeight;
const totalNeeded = minPriceChartHeight + baseVolumeHeight + desiredIndicatorsHeight;</p>
<p>let priceChartHeight;
if (availableHeight >= totalNeeded) {
  priceChartHeight = availableHeight - volumeHeight - indicatorsHeight;
} else {
  const scale = availableHeight / totalNeeded;
  priceChartHeight = Math.floor(minPriceChartHeight * scale);
  // ...
}</p>
<p>// Usar displayCandles con inProgressCandle
let displayCandles = [...candlesRef.current];
if (inProgressCandleRef.current) {
  displayCandles.push(inProgressCandleRef.current);
}</p>
<p>// Calcular precio en mouse ANTES del zoom
const priceAtMouse = minPrice +
  (marginTop + priceChartHeight - mouseY + oldVerticalOffset) / oldYScale;</p>
<p>// Aplicar zoom y calcular nuevo offset
const newVerticalOffset = mouseY - marginTop - priceChartHeight +
  (priceAtMouse - minPrice) * newYScale;
</code></pre></p>
<p><strong>Resultado</strong>: El precio bajo el cursor permanece fijo durante el zoom</p>
<h3>3. Indicador de Timeframe</h3>
<p><strong>Implementaci√≥n</strong>: <code>MiniChart.jsx:363-370</code></p>
<pre><code class="language-javascript">// Mostrar timeframe en esquina superior derecha
ctx.fillStyle = "#2196F3";
ctx.font = "bold 14px Inter, sans-serif";
const timeframeText = interval;
const timeframeWidth = ctx.measureText(timeframeText).width;
ctx.fillRect(width - marginRight - timeframeWidth - 16, 6, timeframeWidth + 12, 20);
ctx.fillStyle = "#FFFFFF";
ctx.fillText(timeframeText, width - marginRight - timeframeWidth - 10, 20);
</code></pre>
<p><strong>Prop√≥sito</strong>: Identificar timeframe en modo pantalla completa</p>
<h3>4. Botones de Acci√≥n</h3>
<p><strong>Reposicionamiento</strong>: <code>MiniChart.jsx:1048-1058</code></p>
<p>Ubicados en esquina superior derecha (debajo del timeframe):
<ul><li>‚õ∂ Pantalla completa</li>
<li>‚Üí| Ir a √∫ltima vela</li>
<li>VP Configuraci√≥n</li>
<li>üéØ Range Detection</li>
<li>üìä Fixed Range Profiles</li>
</ul>
<strong>Fix CSS</strong>: Eliminado <code>position: absolute</code> conflictivo de:
<ul><li><code>.fullscreen-btn</code></li>
<li><code>.goto-latest-btn</code></li>
<li><code>.vp-chart-settings-btn</code></li>
<li><code>.fixed-range-manager-btn</code></li>
</ul>
Ahora controlados por contenedor flex.</p>
<hr>
<h2>Configuraci√≥n y Personalizaci√≥n</h2>
<h3>Panel de Configuraci√≥n</h3>
<p><strong>Acceso</strong>: Bot√≥n üéØ en cada gr√°fico</p>
<p><strong>Par√°metros Ajustables</strong>:</p>
<ul><li><strong>M√≠nimo de velas en rango</strong> (minRangeLength)</li>
</ul>   - Default: 20
   - Rango: 10-100
   - Descripci√≥n: N√∫mero m√≠nimo de velas para validar un rango
<ul><li><strong>Multiplicador ATR</strong> (atrMultiplier)</li>
</ul>   - Default: 1.0
   - Rango: 0.5-3.0
   - Descripci√≥n: Ajusta el ancho de las bandas de rango
<ul><li><strong>Per√≠odo ATR</strong> (atrLength)</li>
</ul>   - Default: 200
   - Rango: 50-500
   - Descripci√≥n: N√∫mero de velas para calcular el ATR
<ul><li><strong>M√°ximo de rangos activos</strong> (maxActiveRanges)</li>
</ul>   - Default: 10
   - Rango: 1-20
   - Descripci√≥n: L√≠mite de rangos detectados simult√°neos
<ul><li><strong>Crear VP Fixed Range</strong> (autoCreateFixedRange)</li>
</ul>   - Default: true
   - Descripci√≥n: Crear autom√°ticamente VP en rangos detectados
<ul><li><strong>Velas para confirmar breakout</strong> (maxBreakoutCandles)</li>
</ul>   - Default: 5
   - Rango: 1-20
   - Descripci√≥n: Velas consecutivas fuera del rango para confirmar salida
<ul><li><strong>Crear VP de tendencias</strong> (createTrendProfiles)</li>
</ul>   - Default: false
   - Descripci√≥n: Crear VP en gaps entre rangos
<ul><li><strong>Mostrar otros timeframes</strong> (showOtherTimeframes)</li>
</ul>   - Default: false
   - Descripci√≥n: Mostrar rangos detectados en otros intervalos
<h3>Activaci√≥n por S√≠mbolo</h3>
<p><strong>Toggle Principal</strong>: Activa/desactiva Range Detection para el s√≠mbolo</p>
<p><strong>Persistencia</strong>:
<pre><code class="language-javascript">localStorage: 'range_detection_enabled_symbols'
Formato: ["BTCUSDT", "ETHUSDT", ...]
</code></pre></p>
<h3>Lista de Rangos Detectados</h3>
<p><strong>UI Features</strong>:
<ul><li>Checkbox individual para mostrar/ocultar</li>
<li>Badge con etiqueta (A, B, C...)</li>
<li>Badge con timeframe (15m, 1h, etc.)</li>
<li>Score de detecci√≥n</li>
<li>Fechas de inicio/fin</li>
<li>Alternancia de colores de fila</li>
</ul>
<strong>Ejemplo</strong>:
<pre><code class="language-">‚òë [A] Rango #1 Score: 8.5 [15m]
  01 Nov 14:30 ‚Üí 01 Nov 18:45</p>
<p>‚òë [B] Rango #2 Score: 7.2 [15m]
  02 Nov 09:15 ‚Üí 02 Nov 12:00
</code></pre></p>
<hr>
<h2>Archivos del Sistema</h2>
<h3>Componentes React</h3>
<ul><li><strong>MiniChart.jsx</strong> (1200+ l√≠neas)</li>
</ul>   - Componente principal del gr√°fico
   - Renderizado en canvas
   - Gesti√≥n de interacciones (zoom, pan, crosshair)
   - Integraci√≥n con IndicatorManager
<ul><li><strong>RangeDetectionSettings.jsx</strong> (500+ l√≠neas)</li>
</ul>   - Modal de configuraci√≥n
   - Controles de par√°metros ATR
   - Lista de rangos detectados
   - Toggles de features
<ul><li><strong>FixedRangeProfilesManager.jsx</strong></li>
</ul>   - Gesti√≥n de rangos manuales
   - Creaci√≥n/edici√≥n/eliminaci√≥n
   - Selector de fechas
<h3>Indicadores</h3>
<ul><li><strong>ATRBasedRangeDetector.js</strong> (400+ l√≠neas)</li>
</ul>   - Algoritmo de detecci√≥n
   - C√°lculo de ATR
   - Gesti√≥n de rangos activos
   - Etiquetado alfab√©tico
<ul><li><strong>IndicatorManager.js</strong> (800+ l√≠neas)</li>
</ul>   - Coordinador de indicadores
   - Sincronizaci√≥n con localStorage
   - Filtrado por timeframe
   - Renderizado de Volume Profiles
<ul><li><strong>VolumeProfileFixedRangeIndicator.js</strong> (600+ l√≠neas)</li>
</ul>   - C√°lculo de Volume Profile
   - Detecci√≥n de clusters
   - Renderizado en canvas
   - Configuraci√≥n personalizada
<ul><li><strong>IndicatorBase.js</strong></li>
</ul>   - Clase abstracta base
   - Interfaz com√∫n para indicadores
<h3>Estilos</h3>
<ul><li><strong>styles.css</strong></li>
</ul>   - Estilos de botones (hover effects)
   - Modal styles
   - Layout de gr√°ficos
<hr>
<h2>Flujo de Datos</h2>
<h3>1. Inicializaci√≥n</h3>
<pre><code class="language-">User navega a Watchlist
  ‚Üì
MiniChart.jsx monta
  ‚Üì
IndicatorManager creado
  ‚Üì
loadRangeDetectionConfig()
  ‚Üì
localStorage ‚Üí config por s√≠mbolo+timeframe
  ‚Üì
Si enabled: enableRangeDetection(config)
  ‚Üì
ATRBasedRangeDetector creado
  ‚Üì
syncFixedRangeIndicators()
  ‚Üì
localStorage ‚Üí rangos detectados
  ‚Üì
VolumeProfileFixedRangeIndicator creado para cada rango
</code></pre>
<h3>2. Actualizaci√≥n de Datos</h3>
<pre><code class="language-">WebSocket recibe tick
  ‚Üì
WebSocketManager distribuye
  ‚Üì
MiniChart actualiza inProgressCandle
  ‚Üì
IndicatorManager.update(candles)
  ‚Üì
RangeDetector.detectRanges(candles)
  ‚Üì
Si nuevo rango detectado:
  ‚Üì
createFixedRangeProfile()
  ‚Üì
VolumeProfileFixedRangeIndicator creado
  ‚Üì
saveFixedRangeProfilesToStorage()
  ‚Üì
localStorage actualizado
  ‚Üì
drawChart() re-renderiza
</code></pre>
<h3>3. Interacci√≥n del Usuario</h3>
<pre><code class="language-">User abre RangeDetectionSettings
  ‚Üì
Muestra config actual + lista de rangos
  ‚Üì
User ajusta par√°metro (ej: atrMultiplier)
  ‚Üì
handleConfigChange()
  ‚Üì
rangeDetector.updateConfig(newConfig)
  ‚Üì
saveRangeDetectionConfig()
  ‚Üì
localStorage actualizado (key: symbol_interval)
  ‚Üì
Si createTrendProfiles activado:
  ‚Üì
createTrendProfilesBetweenRanges()
  ‚Üì
Nuevos VP azules creados
  ‚Üì
saveFixedRangeProfilesToStorage()
  ‚Üì
drawChart() re-renderiza
</code></pre>
<h3>4. Cambio de Timeframe</h3>
<pre><code class="language-">User cambia de 15m a 1h
  ‚Üì
MiniChart useEffect triggered
  ‚Üì
IndicatorManager destruido
  ‚Üì
Nuevo IndicatorManager creado
  ‚Üì
loadRangeDetectionConfig() con nuevo interval
  ‚Üì
localStorage ‚Üí config espec√≠fico de 1h
  ‚Üì
syncFixedRangeIndicators()
  ‚Üì
Filtra rangos: solo interval === "60"
  ‚Üì
renderFixedRangeProfiles() aplica filtro
  ‚Üì
Solo rangos de 1h visibles
</code></pre>
<hr>
<h2>Casos de Uso</h2>
<h3>Caso 1: Trader Swing identificando zonas de consolidaci√≥n</h3>
<p><strong>Objetivo</strong>: Identificar rangos en timeframe 4h para detectar posibles breakouts</p>
<p><strong>Workflow</strong>:
<ul><li>Seleccionar timeframe 4h</li>
<li>Activar Range Detection (bot√≥n üéØ)</li>
<li>Ajustar <code>atrMultiplier</code> a 1.2 (rangos m√°s estrechos)</li>
<li>Ajustar <code>minRangeLength</code> a 30 (rangos m√°s largos)</li>
<li>Activar "Crear VP de tendencias"</li>
<li>Observar:</li>
</ul>   - Rangos p√∫rpura (A, B, C...) = consolidaciones
   - VP azules = tendencias entre rangos
   - Clusters naranjas = soportes/resistencias clave</p>
<p><strong>Resultado</strong>:
<ul><li>3 rangos identificados en la √∫ltima semana</li>
<li>2 zonas de tendencia alcista entre rangos</li>
<li>5 clusters de alto volumen (posibles zonas de reversi√≥n)</li>
</ul>
<h3>Caso 2: Day Trader en timeframe 15m</h3></p>
<p><strong>Objetivo</strong>: Scalping usando micro-rangos del d√≠a</p>
<p><strong>Workflow</strong>:
<ul><li>Seleccionar timeframe 15m</li>
<li>Activar Range Detection</li>
<li>Ajustar <code>atrMultiplier</code> a 0.8 (rangos muy ajustados)</li>
<li>Ajustar <code>minRangeLength</code> a 12 (rangos m√°s cortos)</li>
<li>Ajustar <code>maxBreakoutCandles</code> a 3 (confirmaci√≥n r√°pida)</li>
<li>Desactivar "Mostrar otros timeframes"</li>
<li>Usar checkboxes para ocultar rangos antiguos</li>
</ul>
<strong>Resultado</strong>:
<ul><li>8 micro-rangos detectados en la sesi√≥n</li>
<li>Enfoque solo en los 3 rangos m√°s recientes</li>
<li>Identificaci√≥n r√°pida de breakouts</li>
</ul>
<h3>Caso 3: An√°lisis multi-timeframe</h3></p>
<p><strong>Objetivo</strong>: Comparar rangos de 1h con contexto de 4h</p>
<p><strong>Workflow</strong>:
<ul><li>Seleccionar timeframe 1h</li>
<li>Activar Range Detection en 1h (par√°metros personalizados)</li>
<li>Cambiar a timeframe 4h</li>
<li>Activar Range Detection en 4h (par√°metros diferentes)</li>
<li>Volver a 1h</li>
<li>Activar "Mostrar otros timeframes"</li>
</ul>
<strong>Resultado</strong>:
<ul><li>Rangos de 1h (p√∫rpura) superpuestos con rangos de 4h</li>
<li>Identificaci√≥n de confluencias (rangos que coinciden)</li>
<li>Mejor timing para entradas (micro-rango dentro de macro-rango)</li>
</ul>
<hr></p>
<h2>Almacenamiento en localStorage</h2>
<h3>Estructura de Datos</h3>
<p>#### 1. S√≠mbolos con Range Detection Activo</p>
<pre><code class="language-javascript">Key: 'range_detection_enabled_symbols'
Value: ["BTCUSDT", "ETHUSDT", "SOLUSDT"]
</code></pre>
<p>#### 2. Configuraci√≥n por S√≠mbolo+Timeframe</p>
<pre><code class="language-javascript">Key: 'range_detection_config_BTCUSDT_15'
Value: {
  enabled: true,
  config: {
    minRangeLength: 20,
    atrMultiplier: 1.0,
    atrLength: 200,
    maxActiveRanges: 10,
    autoCreateFixedRange: true,
    maxBreakoutCandles: 5,
    createTrendProfiles: false,
    showOtherTimeframes: false
  },
  lastUpdate: 1699123456789
}
</code></pre>
<p>#### 3. Rangos Detectados (Fixed Range Profiles)</p>
<pre><code class="language-javascript">Key: 'volumeprofile_fixed_ranges_v2'
Value: [
  {
    rangeId: "range_BTCUSDT_15_001",
    symbol: "BTCUSDT",
    interval: "15",
    startTimestamp: 1699000000000,
    endTimestamp: 1699010000000,
    enabled: true,
    isAutoDetected: true,
    isTrendProfile: false,
    rangeLabel: "A",
    detectionScore: 8.5,
    rows: 100,
    valueAreaPercent: 70,
    histogramMaxWidth: 25,
    useGradient: true,
    baseColor: "#9C27B0",
    valueAreaColor: "#BA68C8",
    pocColor: "#7B1FA2",
    vahValColor: "#AB47BC",
    rangeShadeColor: "#E1BEE7",
    enableClusterDetection: true,
    clusterThreshold: 1.5,
    clusterColor: "#E65100"
  },
  {
    rangeId: "trend_1699010000000_1699020000000",
    symbol: "BTCUSDT",
    interval: "15",
    startTimestamp: 1699010000000,
    endTimestamp: 1699020000000,
    enabled: true,
    isAutoDetected: true,
    isTrendProfile: true,
    rows: 50,
    valueAreaPercent: 70,
    baseColor: "#2196F3",
    clusterColor: "#FF6F00",
    // ...
  }
]
</code></pre>
<hr>
<h2>Optimizaciones Implementadas</h2>
<h3>1. Renderizado Condicional</h3>
<ul><li>Solo renderizar rangos del timeframe actual (filtrado)</li>
<li>Checkboxes para ocultar rangos individualmente</li>
<li>Destrucci√≥n correcta de indicadores al cambiar timeframe</li>
</ul>
<h3>2. Cach√© de C√°lculos</h3>
<ul><li>ATR calculado una vez por actualizaci√≥n</li>
<li>Volume Profile bins cacheados</li>
<li>displayCandles filtrado eficientemente</li>
</ul>
<h3>3. localStorage Granular</h3>
<ul><li>Configuraci√≥n separada por s√≠mbolo+timeframe</li>
<li>Evita colisiones entre s√≠mbolos</li>
<li>Carga solo datos relevantes</li>
</ul>
<h3>4. Lazy Loading de Trend Profiles</h3>
<ul><li>Solo creados cuando toggle activado</li>
<li>Eliminados autom√°ticamente cuando desactivado</li>
<li>No afectan performance si no se usan</li>
</ul>
<hr>
<h2>Pr√≥ximas Mejoras Sugeridas</h2>
<h3>1. Drag-to-Resize Ranges</h3>
<ul><li>Permitir ajustar rangos arrastrando bordes</li>
<li>Handles visuales en bordes verticales</li>
<li>Opci√≥n C del an√°lisis de complejidad (2.5 horas estimadas)</li>
</ul>
<h3>2. Range Templates</h3>
<ul><li>Guardar configuraciones ATR como presets</li>
<li>"Conservative", "Moderate", "Aggressive"</li>
<li>Aplicaci√≥n con un click</li>
</ul>
<h3>3. Estad√≠sticas de Rangos</h3>
<ul><li>Duraci√≥n promedio</li>
<li>Tasa de breakout exitoso vs falso</li>
<li>Mejor timeframe para cada s√≠mbolo</li>
</ul>
<h3>4. Alertas de Breakout</h3>
<ul><li>Notificaci√≥n cuando se confirma breakout</li>
<li>Integraci√≥n con sistema de alertas existente</li>
<li>Configuraci√≥n de sensibilidad</li>
</ul>
<h3>5. Exportaci√≥n de Datos</h3>
<ul><li>CSV con rangos detectados</li>
<li>An√°lisis hist√≥rico</li>
<li>Backtesting de estrategias</li>
</ul>
<hr>
<h2>Conclusiones</h2>
<p>El sistema de <strong>Range Detector</strong> representa una herramienta avanzada de an√°lisis t√©cnico que:</p>
<p><span class="checkmark">‚úÖ</span> <strong>Automatiza</strong> la identificaci√≥n de zonas de consolidaci√≥n
<span class="checkmark">‚úÖ</span> <strong>Integra</strong> seamlessly con Volume Profile para an√°lisis de volumen
<span class="checkmark">‚úÖ</span> <strong>Personaliza</strong> configuraciones por s√≠mbolo y timeframe
<span class="checkmark">‚úÖ</span> <strong>Persiste</strong> datos y configuraciones para an√°lisis continuo
<span class="checkmark">‚úÖ</span> <strong>Optimiza</strong> la experiencia del usuario con UI intuitiva</p>
<h3>Impacto en el Trading</h3>
<ul><li><strong>Reducci√≥n de tiempo</strong>: Detecci√≥n autom√°tica vs an√°lisis manual</li>
<li><strong>Objetividad</strong>: Criterios matem√°ticos (ATR) vs subjetividad</li>
<li><strong>Consistencia</strong>: Mismos par√°metros aplicados sistem√°ticamente</li>
<li><strong>Contexto</strong>: Integraci√≥n con Volume Profile para decisiones informadas</li>
</ul>
<h3>M√©tricas de √âxito</h3>
<ul><li><span class="checkmark">‚úÖ</span> 100% de funcionalidades implementadas seg√∫n spec</li>
<li><span class="checkmark">‚úÖ</span> Persistencia robusta en localStorage</li>
<li><span class="checkmark">‚úÖ</span> UI responsive y intuitiva</li>
<li><span class="checkmark">‚úÖ</span> Performance optimizada (no lag en charts)</li>
<li><span class="checkmark">‚úÖ</span> C√≥digo mantenible y extensible</li>
</ul>
<hr>
<h2>Anexo: Referencias T√©cnicas</h2>
<h3>F√≥rmulas Clave</h3>
<p><strong>True Range (TR)</strong>:
<pre><code class="language-">TR = max(
  High - Low,
  |High - Previous Close|,
  |Low - Previous Close|
)
</code></pre></p>
<p><strong>Average True Range (ATR)</strong>:
<pre><code class="language-">ATR = SMA(TR, period)
</code></pre></p>
<p><strong>Bandas de Rango</strong>:
<pre><code class="language-">Upper Band = Initial High + (ATR √ó multiplier)
Lower Band = Initial Low - (ATR √ó multiplier)
</code></pre></p>
<p><strong>Detecci√≥n de Rango</strong>:
<pre><code class="language-">In Range = (Low >= Lower Band) AND (High <= Upper Band)
</code></pre></p>
<p><strong>Breakout Confirmado</strong>:
<pre><code class="language-">Breakout = (consecutive candles outside bands) >= maxBreakoutCandles
</code></pre></p>
<h3>Colores del Sistema</h3>
<table><thead><tr><th>Elemento</th><th>Hex Code</th><th>Uso</th></tr></thead><tbody><tr><td>Rangos p√∫rpura</td><td>#9C27B0</td><td>Base de rangos laterales</td></tr><tr><td>Tendencias azul</td><td>#2196F3</td><td>VP entre rangos</td></tr><tr><td>Clusters naranja oscuro</td><td>#E65100</td><td>Clusters en rangos</td></tr><tr><td>Clusters naranja brillante</td><td>#FF6F00</td><td>Clusters en tendencias</td></tr><tr><td>POC p√∫rpura oscuro</td><td>#7B1FA2</td><td>Point of Control</td></tr><tr><td>VA p√∫rpura claro</td><td>#BA68C8</td><td>Value Area</td></tr></tbody></table>
<h3>Archivos Clave - L√≠neas de C√≥digo</h3>
<table><thead><tr><th>Archivo</th><th>L√≠neas</th><th>Descripci√≥n</th></tr></thead><tbody><tr><td>ATRBasedRangeDetector.js</td><td>~400</td><td>Algoritmo detecci√≥n</td></tr><tr><td>IndicatorManager.js</td><td>~800</td><td>Coordinaci√≥n indicadores</td></tr><tr><td>VolumeProfileFixedRangeIndicator.js</td><td>~600</td><td>Volume Profile</td></tr><tr><td>MiniChart.jsx</td><td>~1200</td><td>Rendering + UX</td></tr><tr><td>RangeDetectionSettings.jsx</td><td>~500</td><td>UI configuraci√≥n</td></tr></tbody></table>
<strong>Total</strong>: ~3500 l√≠neas de c√≥digo core
<hr>
<h2>Ap√©ndice: Sesi√≥n de Desarrollo Actual</h2>
<h3>Cambios en Esta Sesi√≥n</h3>
<ul><li><strong>Fix Zoom Vertical</strong> (MiniChart.jsx:694-755)</li>
</ul>   - Problema: No anclaba en posici√≥n del mouse
   - Soluci√≥n: Sincronizaci√≥n exacta con drawChart calculations
<ul><li><strong>Indicador Timeframe</strong> (MiniChart.jsx:363-370)</li>
</ul>   - Badge azul en esquina superior derecha
   - Visible en pantalla completa
<ul><li><strong>Restauraci√≥n Botones</strong> (styles.css)</li>
</ul>   - Eliminado position absolute conflictivo
   - Todos los botones visibles
<ul><li><strong>Reposicionamiento UI</strong> (MiniChart.jsx:1048-1058)</li>
</ul>   - Botones movidos a derecha
   - No obstruyen nombre de s√≠mbolo
<h3>Estado Final</h3>
<p><span class="checkmark">‚úÖ</span> Todas las funcionalidades operativas
<span class="checkmark">‚úÖ</span> UI optimizada y sin obstrucciones
<span class="checkmark">‚úÖ</span> Zoom/Pan funcionando correctamente
<span class="checkmark">‚úÖ</span> Range Detection totalmente funcional
<span class="checkmark">‚úÖ</span> Persistencia en localStorage correcta</p>
<hr>
<p><strong>Documento Generado</strong>: 2024
<strong>Versi√≥n del Sistema</strong>: 1.0
<strong>Autor</strong>: Claude Code Development Session
</p>
</body>
</html>